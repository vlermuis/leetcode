#include <stdio.h>
#include <stdlib.h>

/*
Code Design Test: Data Compression Design
Design an algorithm that will compress a given data buffer of bytes. Please describe your design and submit an implementation in a language of your choice.
The algorithm will live within a function.  This function will be called with two arguments; a pointer to the data buffer (data_ptr) and the number of bytes to compress (data_size).  After the function executes the data in the buffer will be modified and the size of the modified buffer will be returned.
Assumptions:
1.	The data_ptr will point to an array of bytes.  Each byte will contain a number from 0 to 127 (0x00 to 0x7F).  It is common for the data in the buffer to have the same value repeated in the series.
2.	The compressed data will need to be decompressable.  Please ensure that your algorithm allows for a decompression algorithm to return the buffer to it’s previous form.
Example data and function call:
// Data before the call
// data_ptr[] = { 0x03, 0x74, 0x04, 0x04, 0x04, 0x35, 0x35, 0x64,
//                0x64, 0x64, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,
//                0x56, 0x45, 0x56, 0x56, 0x56, 0x09, 0x09, 0x09 };
// data_size = 24;

new_size = byte_compress( data_ptr, data_size );
*/

typedef unsigned char byte;

#define SPBYTE_MASK     (0x80) // we use first bit(7b) as indication of special byte
#define DATA_MASK_7B    (0x7F)

/*
I decided to go with RLE(Run-length encoding) algorithm, as task description mentions
that it is common for data in buffer to have the same value repeated in series.
RLE is a form of lossless data compression in which runs of data (sequences in which
the same data value occurs in many consecutive data elements)are stored as a single data value and count.
Task description says also that the data in each byte is limited from 0 to 127(0 to 0xF7)
which leaves bit 7(PC CPU uses little-endian, so 0xF7 = 0b0111111)
This bit can be used as a marker and would tell decoder that next byte will contain
number of repeats of value stored in previous special byte marked with 7bit set 1.

The compress function "byte_compress()" checks each byte from start if there is a sequence
by calling "check_sequence()".
"check_sequence()" returns number of digits in sequence, not including the very first element.
If sequence number is less than 0xFF(because this is maximum number we can save in a byte),
the first byte becomes the special byte. We apply bit mask which sets 7bit to 1.
If sequence number is bigger than 0xFF, we set it to 0xFF and process it as described above.
We repeat these steps until we reach the end of the buffer.

__________________________________________________________________________________
*/

/*
 function will shift left in "data" with initial size "data_size" from
  "position" + "shift" to "position"

before shifting:
  #############@@@@@@@@@@@@@@@@@@@@@@@@@################
       position^       position + shift^

 after shifting:
  #############################.........................

params:
  data: pointer to start of the buffer
  data_size: initial data size
  position : target position
  shift : how much shift to do
*/
void shift_left(byte* data, int data_size,int position, int shift)
{
   int i;
    for (i = position; i < data_size - shift; i++)
    {
        data[i] = data[i + shift];
    }
}
/*
 function checks if there is a sequence of current element further in the row
 params:
  data: pointer to start of the buffer
  data_size: data size
  position : start checking element from position
return:
 number elements after position (so total number of the same elements will be +1)
*/
int check_sequence(byte* data, int data_size, int position)
{
    int i = 0;
    int idx = 0;
    for (i = position; i < data_size -1; i++)
    {
        if (data[position] != data[i + 1])
        {
            break;
        }
        idx++;
    }
    return idx;
}
/*
 function compresses data, replace sequences of the same number(if its more than 2 bytes) by
  2 bytes first byte number itself marked with 7bit to 1 and second byte number of repeats(excluding first one)
 params:
  data_ptr: pointer to start of the buffer
  data_size : data size
return:
 new data size
*/
int byte_compress(byte* data_ptr, int data_size)
{
    int i;
    for (i = 0; i < data_size; i++)
    {
        int seq = check_sequence(data_ptr, data_size, i);
        seq++; // to include the very first element;
        if (seq > 2)
        {/* if there is a sequence a more than 2 the same digits in a row
            it worth to pack to save "n = m - 2" bytes
            n - number bytes to save
            m - total number of bytes in a sequence */
            if (seq > 0xFF)
            {
                seq = 0xFF; // we can use 7bit for data as we not going to check for special byte this counter
            }
            data_ptr[i] |= SPBYTE_MASK;
            data_ptr[i+1] = seq;
            shift_left(data_ptr, data_size, i + 2, seq - 2);
            data_size -= (seq - 2);
            i++; // skip next element as we store number of repetitions there
            //display_array(data_ptr, data_size);
            //printf("%d\n", data_size);
        }
    }
    return data_size;
}
/*
 function decompresses data
 function allocates memory for new buffer because we cannot be sure that its enough space in buffer
 for unpack the data
 this buffer has to be freed after functions calls
params:
  data_ptr: pointer to start of the buffer
  data_size : data size
  new_data_size: pointer to integer where packed buffer size have to be written
return:
 pointer to new packed buffer
*/
byte* byte_decompress(byte* data_ptr, int data_size, int* new_data_size)
{
    /* go through data first to calculate the size after decompressing
    new buffer for unpacked data will be malloced and should be free after function call */
    int i,j;
    int ni = 0;
    int new_size = data_size;
    for (i = 0; i < data_size; i++)
    {
        if ((data_ptr[i] & SPBYTE_MASK) == SPBYTE_MASK)
        {
            new_size += data_ptr[i + 1] - 2;
            i++;//as next one is number of repeats
        }
    }
    *new_data_size = new_size;
    /*allocate memory for new unpacked buffer */
    byte* new_data_ptr = (byte*)malloc(sizeof(byte)*new_size);
    if (new_data_ptr == NULL)
    {/* cannot allocate this much */
        *new_data_ptr = 0;
        return NULL;
    }

    for (i = 0; i < data_size; i++)
    {
        if ((data_ptr[i] & SPBYTE_MASK) == SPBYTE_MASK)
        {/* if its a special byte marked with 7b
            clear that bit and fill up the sequence in new buffer*/
            byte repeated_element = data_ptr[i] & DATA_MASK_7B;
            for (j = 0; j < data_ptr[i + 1]; j++)
            {
                new_data_ptr[ni] = repeated_element;
                ni++;
            }
            i++;
        }
        else
        {
            new_data_ptr[ni] = data_ptr[i];
            ni++;
        }
    }
    return new_data_ptr;
}
/**** Debug and test functions *****************************************/

/* calculating crc for comparing origin and after unpacking buffers */
static const unsigned short crc16tab[256] =
{
    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
	0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
	0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
	0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
	0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
	0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
	0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
	0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
	0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
	0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
	0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
	0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
	0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
	0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
	0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
	0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
	0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
	0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
	0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
	0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
	0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
	0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
	0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
	0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
	0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
	0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
	0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
	0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
	0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
	0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
	0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
	0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

unsigned int crc16_ccitt(const unsigned char* buf, int len)
{
	unsigned counter;
	unsigned int crc = 0;
	for( counter = 0; counter < len; counter++)
		crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *(char *)buf++)&0x00FF];
	return crc;
}

void display_array(byte* arr, int arr_size)
{
    int i;
    for (i = 0; i < arr_size; i++)
    {
        printf("0x%x, ", arr[i]);
    }
    printf("\n");
}

int compare_data(byte* data0, int data0_size, byte* data1, int data1_size)
{
    int i;
    if (data0_size != data1_size)
    {
        return 0;
    }
    for (i = 0; i < data0_size; i++)
    {
        if (data0[i] != data1[i])
        {
            return 0;
        }
    }
    return 1;
}




/*
 function runs test cases, it takes buffer and size as parameters
 save original into copy, does pack and unpack and check crc of both
  and print result
  data_ptr: pointer to start of the buffer
  data_size : data size

*/
void do_test_case(byte* data_ptr, int data_size, int test_case_num)
{
    unsigned int crc_origin = crc16_ccitt(data_ptr, data_size); // get original buffer crc for future verification
    int nsize = byte_compress(data_ptr, data_size);
    int unpack_size = 0;
    byte* unpack_data = byte_decompress(data_ptr, nsize, &unpack_size);
    printf("origin size:%d ; packed size:%d   -",data_size, nsize);
    unsigned int crc_unpack = crc16_ccitt(unpack_data, unpack_size);
    if (crc_origin == crc_unpack)
    {
        printf("test case %d passed....ok\n", test_case_num);
    }
    else
    {
        printf("test case %d not passed....error!\n", test_case_num);
    }
    free(unpack_data);
}


/***********************************************************************/


byte data_ptr[] = { 0x03, 0x74, 0x04, 0x04, 0x04, 0x35, 0x35, 0x64,
                0x64, 0x64, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x56, 0x45, 0x56, 0x56, 0x56, 0x09, 0x09, 0x09 };
int data_size = 24;

byte data_ptr1[] = { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
                0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
                0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
int data_size1 = 24;

byte data_ptr2[] = {};
int data_size2 = 0;

byte data_ptr3[] = {0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09
                   };
int data_size3 = 160;

byte data_ptr4[] = {0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
                   0x09};
int data_size4 = 321;

byte data_ptr5[] = {0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09};
int data_size5 = 12;

int main()
{
    do_test_case(data_ptr, data_size, 0);
    do_test_case(data_ptr1, data_size1, 1);
    do_test_case(data_ptr2, data_size2, 2);
    do_test_case(data_ptr3, data_size3, 3);
    do_test_case(data_ptr4, data_size4, 4);
    do_test_case(data_ptr5, data_size5, 5);
    return 0;
}
